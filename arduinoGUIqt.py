import ui_plot as ui_plot #this was generated by pyuic4 command
import sys
import numpy as np
from PyQt4 import QtCore, QtGui, Qt
import PyQt4.Qwt5 as Qwt
import serial.tools.list_ports
import time
import csv
# import ctypes
from threading import Thread

#Phidget imports for load cell
# from Phidgets.PhidgetException import PhidgetException
# from Phidgets.Devices.Bridge import Bridge, BridgeGain
import Phidget_Monitor
#Arduino stuff
from Arduino_Monitor import SerialData

REPLOT_INTERVAL_MS = 30
READ_DATA_INTERVAL_MS = 14
SAVE_DATA_RATE_S = 5
READ_PHIDGET_BOARDS_INTERVAL_MS = 10
PRESSURE_SENSOR_TANK_PIN_INDEX = 2
PRESSURE_SENSOR_COMBUSTION_CHAMBER_PIN_INDEX = 1
PRESSURE_SENSOR_UPSTREAM_ORIFACE_PIN_INDEX = 2
ARDUINO_COMMANDS = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
# VALVE 1 = FILL VALVE
VALVE_1_OPEN_INDEX = 0 #a
VALVE_1_CLOSE_INDEX = 1 #b 
# VALVE 2 = UPSTREAM MAIN VALVE
VALVE_2_OPEN_INDEX = 2 #c
VALVE_2_CLOSE_INDEX = 3 #d
# VALVE 3 = DOWNSTREAM MAIN VALVE
VALVE_3_OPEN_INDEX = 4 #e
VALVE_3_CLOSE_INDEX = 5 #f
# VALVE 4 = FLIGHT TANK VENT VALVE
VALVE_4_OPEN_INDEX = 6 #g
VALVE_4_CLOSE_INDEX = 7 #h
# VALVE 5 = NITROUS VENT VALVE
VALVE_5_OPEN_INDEX = 8 #i
VALVE_5_CLOSE_INDEX = 9 #j
# VALVE 6 = NITROGEN PURGE VALVE
VALVE_6_OPEN_INDEX = 10 #k
VALVE_6_CLOSE_INDEX = 11 #l
VENT_INDEX = 12 #m
LAUNCH_INDEX = 13 #n
IGNITER_ON_INDEX = 14 #o
IGNITER_OFF_INDEX = 15 #p
PURGE_INDEX = 16 #q
STOP_LAUNCH_INDEX = 17 #r
ABORT_INDEX = 17 #r

#Palette colors
paletteClosed = Qt.QPalette()
paletteClosed.setColor(Qt.QPalette.Foreground,Qt.Qt.red)
paletteOpen = Qt.QPalette()
paletteOpen.setColor(Qt.QPalette.Foreground,Qt.Qt.green)

#ARDUINO SETUP
#get the com ports of the arduino
possible_com_ports = []
for possible_com in list(serial.tools.list_ports.comports()):
    possible_com_ports.append(possible_com[0])
    if possible_com[1].count('Arduino') == 1:
#     if possible_com[2].count('FTDIBUS\\VID_0403+PID_6001+A602QNNGA\\0000') == 1:
        com_port_micro = possible_com[0]
    if possible_com[2].count('FTDIBUS\\VID_0403+PID_6001+A800K5EZA\\0000') == 1:
        com_port_mega = possible_com[0]
# try to connect to all arduinos
try:
    arduinoMicro = SerialData(com_port_micro)
    arduinoMicroConnected = True
except:
    'Arduino Micro not found'
    arduinoMicroConnected = False
try:    
    arduinoMega = SerialData(com_port_mega)
    arduinoMegaConnected = True
except:
    print 'Arduino Mega not found'
    arduinoMegaConnected = False

#PHIDGET BOARD SETUP (FOR LOAD CELL)
phidgetLoadCell = Phidget_Monitor.PhidgetBridge() 
phidgetThermocouples = Phidget_Monitor.PhidgetTemp()
#open the phidget
loadCellConnected = phidgetLoadCell.open(500) #wait 500 ms before timeout    
thermocouplesConnected = phidgetThermocouples.open(500)

pin_data = [[],[],[],[],[],[]] #6 pins
time_data = []
scale_data = []
time_data_scale = []
load_cell_data = []
load_cell_times = []
tc0_data = []
tc1_data = []
tc2_data = []
tc3_data = []
tc_times = []
light_on_times = []
light_off_times = []
launch1_times = []
launch2_times = []
launch3_times = []
launch4_times = []
purge1_times = []
purge2_times = []
purge3_times = []
purge4_times = []
purge5_times = []
purge6_times = []
sample_rate = 0
textHistory = []
python_start_time_s = time.time()
python_time_at_first_arduino_time = time.time()
python_time_at_first_scale_time = time.time()
max_points_plotting = 5000

savingData = False
shutdown = False

time_text = str('%04i' %time.localtime().tm_year) + str('%02i' %time.localtime().tm_mon) + \
    str('%02i' %time.localtime().tm_mday) + str('%02i' %time.localtime().tm_hour) + str('%02i' %time.localtime().tm_min) + \
    str('%02i' %time.localtime().tm_sec)
save_filename_data = 'data' + time_text + '.csv'
save_filename_text = 'text' + time_text + '.csv'

def plotSomething():
    #make sure there is data to plot
    if len(time_data) > 0:
        #convert shift time data so it starts at 0
        if len(time_data) > 0:
            time_data_shifted = time_data-time_data[0]
            plot_pressure = True
        else:
            plot_pressure = False
        if len(time_data_scale) > 0 and uiplot.checkBoxScale.isChecked():
#             time_data_scale_shifted = time_data_scale - time_data_scale[0]
            time_data_scale_shifted = time_data_scale - time_data[0]
            plot_scale = True
        else:
            plot_scale = False
        if len(load_cell_times) > 0 and uiplot.checkBoxLoadCell.isChecked():
            time_data_load_cell_shifted = np.array(load_cell_times) - python_time_at_first_arduino_time
            plot_loadCell = True
        else:
            plot_loadCell = False
        if len(tc_times) > 0 and (uiplot.checkBoxT1.isChecked() or uiplot.checkBoxT2.isChecked() or uiplot.checkBoxT3.isChecked() or uiplot.checkBoxT4.isChecked()):
            time_data_shifted_tc = np.array(tc_times) - python_time_at_first_arduino_time
            plot_tc = True
        else:
            plot_tc = False
            
        #update the time history chart
        #see which radio button is checked
        if uiplot.radioButtonSelectTime.isChecked():
            #get the start and the stop index
            try:
                min_time = float(uiplot.lineEditMinTime.text())
            except:
                min_time = 0
            try:
                max_time = float(uiplot.lineEditMaxTime.text())
            except:
                max_time = time_data_shifted[-1]
            #rescale the x axis
            uiplot.qwtPlot.setAxisScale(Qwt.QwtPlot.xBottom,min_time,np.min([max_time,time_data_shifted[-1]]))
            uiplot.qwtPlot_3.setAxisScale(Qwt.QwtPlot.xBottom,min_time,np.min([max_time,time_data_shifted[-1]]))
            start_index = np.abs(time_data_shifted - min_time).argmin()
            end_index = np.abs(time_data_shifted - max_time).argmin()
            if plot_loadCell:
                start_index_load_cell = np.abs(time_data_load_cell_shifted - min_time).argmin()
                end_index_load_cell = np.abs(time_data_load_cell_shifted - max_time).argmin()
            if plot_scale:
                start_index_scale = np.abs(time_data_scale_shifted - min_time).argmin()
                end_index_scale = np.abs(time_data_scale_shifted - max_time).argmin()
            if plot_tc:
                start_index_tc = np.abs(time_data_shifted_tc - min_time).argmin()
                end_index_tc = np.abs(time_data_shifted_tc - max_time).argmin()
                if end_index_tc == start_index_tc:
                    end_index_tc = start_index_tc+1
        elif uiplot.radioButtonMovingTime.isChecked():
            #plot the moving time
            try:
                min_time = np.max([time_data_shifted[-1] - float(uiplot.lineEditMovingTime.text()),time_data_shifted[0]])
            except:
                min_time = time_data_shifted[0]
            start_index = np.abs(time_data_shifted - min_time).argmin()
            end_index = len(time_data_shifted)
            if plot_loadCell:
                start_index_load_cell = np.abs(time_data_load_cell_shifted - min_time).argmin()
                end_index_load_cell = len(time_data_load_cell_shifted)
            if plot_scale:
                start_index_scale = np.abs(time_data_scale_shifted - min_time).argmin()
                end_index_scale = len(time_data_scale_shifted)
            if plot_tc:
                start_index_tc = np.abs(time_data_shifted_tc - min_time).argmin()
                end_index_tc = len(time_data_shifted_tc)
            uiplot.qwtPlot.setAxisScale(Qwt.QwtPlot.xBottom,min_time,time_data_shifted[-1])
            uiplot.qwtPlot_3.setAxisScale(Qwt.QwtPlot.xBottom,min_time,time_data_shifted[-1])
        else:
            #plot the entire time series
            min_time = 0
            start_index = 0
            end_index = len(time_data_shifted)
            if plot_loadCell:
                start_index_load_cell = 0
                end_index_load_cell = len(time_data_load_cell_shifted)
            if plot_scale:
                start_index_scale = 0
                end_index_scale = len(time_data_scale_shifted)
            if plot_tc:
                start_index_tc = 0
                end_index_tc = len(time_data_shifted_tc)
            #set the x axis to auto scale
            uiplot.qwtPlot.setAxisAutoScale(Qwt.QwtPlot.xBottom)
            uiplot.qwtPlot_3.setAxisAutoScale(Qwt.QwtPlot.xBottom)
        #set the plot data
        #see if we need to average data (only plot 2000 points max)
#         if len(time_data_shifted) >= 4000:
#             #find out how many points we should average in a bin
#             num_points_avg = int(len(time_data_shifted)/2000)
#             data_avg_len = int(len(time_data_shifted)/num_points_avg)
#             time_data_plot = np.average(np.reshape(time_data_shifted[0:],[num_points_avg,]),1)
        #see if we only want to plot every n'th element (we don't want to plot more than 5,000 data points
        num_points_skip_plotting = ((end_index-start_index)/max_points_plotting)+1

        if uiplot.checkBoxP0.isChecked():
            pin0_curve.setData(time_data_shifted[start_index:end_index][::num_points_skip_plotting], pin_data[0][start_index:end_index][::num_points_skip_plotting])
        else:
            pin0_curve.setData([],[])
        if uiplot.checkBoxP1.isChecked():
            pin1_curve.setData(time_data_shifted[start_index:end_index][::num_points_skip_plotting], pin_data[1][start_index:end_index][::num_points_skip_plotting])
        else:
            pin1_curve.setData([],[])
        if uiplot.checkBoxP2.isChecked():
            pin2_curve.setData(time_data_shifted[start_index:end_index][::num_points_skip_plotting], pin_data[2][start_index:end_index][::num_points_skip_plotting])
        else:
            pin2_curve.setData([],[])
        if uiplot.checkBoxP3.isChecked():
            pin3_curve.setData(time_data_shifted[start_index:end_index][::num_points_skip_plotting], pin_data[3][start_index:end_index][::num_points_skip_plotting])
        else:
            pin3_curve.setData([],[])
        if uiplot.checkBoxP4.isChecked():
            pin4_curve.setData(time_data_shifted[start_index:end_index][::num_points_skip_plotting], pin_data[4][start_index:end_index][::num_points_skip_plotting])
        else:
            pin4_curve.setData([],[])
        if uiplot.checkBoxP5.isChecked():
            pin5_curve.setData(time_data_shifted[start_index:end_index][::num_points_skip_plotting], pin_data[5][start_index:end_index][::num_points_skip_plotting])
        else:
            pin5_curve.setData([],[])
        if uiplot.checkBoxT1.isChecked() and plot_tc:
            temp1_curve.setData(time_data_shifted_tc[start_index_tc:end_index_tc][::num_points_skip_plotting],tc0_data[start_index_tc:end_index_tc][::num_points_skip_plotting])
        else:
            temp1_curve.setData([],[])
        if uiplot.checkBoxT2.isChecked() and plot_tc:
            temp2_curve.setData(time_data_shifted_tc[start_index_tc:end_index_tc][::num_points_skip_plotting],tc1_data[start_index_tc:end_index_tc][::num_points_skip_plotting])
        else:
            temp2_curve.setData([],[])
        if uiplot.checkBoxT3.isChecked() and plot_tc:
            temp3_curve.setData(time_data_shifted_tc[start_index_tc:end_index_tc][::num_points_skip_plotting],tc2_data[start_index_tc:end_index_tc][::num_points_skip_plotting])
        else:
            temp3_curve.setData([],[])
        if uiplot.checkBoxT4.isChecked() and plot_tc:
            temp4_curve.setData(time_data_shifted_tc[start_index_tc:end_index_tc][::num_points_skip_plotting],tc3_data[start_index_tc:end_index_tc][::num_points_skip_plotting])
        else:
            temp4_curve.setData([],[])
        #scale data plotting
        if plot_scale:
            scale_curve.setData(time_data_scale_shifted[start_index_scale:end_index_scale][::num_points_skip_plotting], scale_data[start_index_scale:end_index_scale][::num_points_skip_plotting])            
        #load cell plotting
        if plot_loadCell:
            load_cell_curve.setData(time_data_load_cell_shifted[start_index_load_cell:end_index_load_cell][::num_points_skip_plotting], load_cell_data[start_index_load_cell:end_index_load_cell][::num_points_skip_plotting])
        else:
            load_cell_curve.setData([],[])
                                        
        #see if the y axis is manual or auto
        if uiplot.radioButtonManualYT.isChecked():
            #MANUAL Y AXIS!
            #rescale the y axis
            try:
                uiplot.qwtPlot.setAxisScale(Qwt.QwtPlot.yLeft,float(uiplot.lineEditMinYT.text()),float(uiplot.lineEditMaxYT.text()))
                uiplot.qwtPlot_3.setAxisScale(Qwt.QwtPlot.yLeft,float(uiplot.lineEditMinYT.text()),float(uiplot.lineEditMaxYT.text()))
            except:
                uiplot.qwtPlot.setAxisAutoScale(Qwt.QwtPlot.yLeft)
                uiplot.qwtPlot_3.setAxisAutoScale(Qwt.QwtPlot.yLeft)
            start_index = np.abs(time_data_shifted - min_time).argmin()
        else:
            #AUTO Y AXIS!
            uiplot.qwtPlot.setAxisAutoScale(Qwt.QwtPlot.yLeft)
            uiplot.qwtPlot_3.setAxisAutoScale(Qwt.QwtPlot.yLeft)
        if uiplot.radioButtonManualYP.isChecked():
            #MANUAL Y AXIS!
            #rescale the y axis
            try:
                uiplot.qwtPlot.setAxisScale(Qwt.QwtPlot.yRight,float(uiplot.lineEditMinYP.text()),float(uiplot.lineEditMaxYP.text()))
                uiplot.qwtPlot_3.setAxisScale(Qwt.QwtPlot.yRight,float(uiplot.lineEditMinYP.text()),float(uiplot.lineEditMaxYP.text()))
            except:
                uiplot.qwtPlot.setAxisAutoScale(Qwt.QwtPlot.yRight)
                uiplot.qwtPlot_3.setAxisAutoScale(Qwt.QwtPlot.yRight)
            start_index = np.abs(time_data_shifted - min_time).argmin()
        else:
            #AUTO Y AXIS!
            uiplot.qwtPlot.setAxisAutoScale(Qwt.QwtPlot.yRight)
            uiplot.qwtPlot_3.setAxisAutoScale(Qwt.QwtPlot.yRight)
        #plot when buttons were clicked
        if uiplot.checkBoxEvents.isChecked():
            if plot_tc:
                eventYValue = int(np.min([tc3_data[start_index_tc:end_index_tc],tc2_data[start_index_tc:end_index_tc],tc1_data[start_index_tc:end_index_tc],tc0_data[start_index_tc:end_index_tc]]))/10*10
            else:
                eventYValue = 0
            if len(light_on_times) > 0:
                light_on_curve.setData(light_on_times,np.repeat(eventYValue,len(light_on_times)))
            else:
                light_on_curve.setData([],[])
            if len(light_off_times) > 0:
                light_off_curve.setData(light_off_times,np.repeat(eventYValue,len(light_off_times)))
            else:
                light_off_curve.setData([],[])
            if len(launch1_times) > 0:
                launch1_curve.setData(launch1_times,np.repeat(eventYValue,len(launch1_times)))
            if len(launch2_times) > 0:
                launch2_curve.setData(launch2_times,np.repeat(eventYValue,len(launch2_times)))
            if len(launch3_times) > 0:
                launch3_curve.setData(launch3_times,np.repeat(eventYValue,len(launch3_times)))
            if len(launch4_times) > 0:
                launch4_curve.setData(launch4_times,np.repeat(eventYValue,len(launch4_times)))
            if len(purge1_times) > 0:
                purge1_curve.setData(purge1_times,np.repeat(eventYValue,len(purge1_times)))
            if len(purge2_times) > 0:
                purge2_curve.setData(purge2_times,np.repeat(eventYValue,len(purge2_times)))
            if len(purge3_times) > 0:
                purge3_curve.setData(purge3_times,np.repeat(eventYValue,len(purge3_times)))
            if len(purge4_times) > 0:
                purge4_curve.setData(purge4_times,np.repeat(eventYValue,len(purge4_times)))
            if len(purge5_times) > 0:
                purge5_curve.setData(purge5_times,np.repeat(eventYValue,len(purge5_times)))
            if len(purge6_times) > 0:
                purge6_curve.setData(purge6_times,np.repeat(eventYValue,len(purge6_times)))
            
        else:
            light_on_curve.setData([],[])
            light_off_curve.setData([],[])
            launch1_curve.setData([],[])
            launch2_curve.setData([],[])
            launch3_curve.setData([],[])
            launch4_curve.setData([],[])
            purge1_curve.setData([],[])
            purge2_curve.setData([],[])
            purge3_curve.setData([],[])
            purge4_curve.setData([],[])
            purge5_curve.setData([],[])
            purge6_curve.setData([],[])
        uiplot.qwtPlot.replot()
        uiplot.qwtPlot_3.replot()
        
        #update the bar chart
#         pin0_bar.setData([-0.3,-0.3,0.3,0.3],[0,pin_data[0][-1],pin_data[0][-1],0])
#         pin1_bar.setData([0.7,0.7,1.3,1.3],[0,pin_data[1][-1],pin_data[1][-1],0])
#         pin2_bar.setData([1.7,1.7,2.3,2.3],[0,pin_data[2][-1],pin_data[2][-1],0])
#         pin3_bar.setData([2.7,2.7,3.3,3.3],[0,pin_data[3][-1],pin_data[3][-1],0])
#         pin4_bar.setData([3.7,3.7,4.3,4.3],[0,pin_data[4][-1],pin_data[4][-1],0])
#         pin5_bar.setData([4.7,4.7,5.3,5.3],[0,pin_data[5][-1],pin_data[5][-1],0])
        #sample_rate_bar.setData([6.5,6.5,7.5,7.5],[0,sample_rate,sample_rate,0])
#         uiplot.qwtPlot_2.replot()
        
        #update the labels
        uiplot.label_1.setText("Pressure 0: %.2f PSI" % (pin_data[0][-1]))
        uiplot.label_2.setText("Pressure 1: %.2f PSI" % (pin_data[1][-1]))
        uiplot.label_3.setText("Pressure 2: %.2f PSI" % (pin_data[2][-1]))
#         uiplot.label_4.setText("Pin 3: %.2f V" % (pin_data[3][-1]))
#         uiplot.label_5.setText("Pin 4: %.2f V" % (pin_data[4][-1]))
#         uiplot.label_6.setText("Pin 5: %.2f V" % (pin_data[5][-1]))
        if len(tc0_data) > 0:
            uiplot.label_4.setText("Temp 1 (CW): %.2f C" % (tc0_data[-1]))
            uiplot.label_5.setText("Temp 2 (PC): %.2f C" % (tc1_data[-1]))
            uiplot.label_6.setText("Temp 3 (GT): %.2f C" % (tc2_data[-1]))
            uiplot.label_21.setText("Temp 4 (TW): %.2f C" % (tc3_data[-1]))
        if len(scale_data) > 0:
            uiplot.label_22.setText("Scale: %.3f kg" % (scale_data[-1]))
        if len(load_cell_data) > 0:
            uiplot.label_23.setText("Load Cell: %.2f N" % (load_cell_data[-1]))
            
        #uiplot.label_7.setText("Sample Rate: " + str(sample_rate) + " Hz")
        uiplot.label_7.setText("Average Sample Rate: %.1f Hz" % (len(time_data_shifted)/(time_data_shifted[-1]-time_data_shifted[0])))

def readPhidgetBoards():
    global load_cell_data
    global load_cell_times
    global tc0_data
    global tc1_data
    global tc2_data
    global tc3_data
    global tc_times
    global phidgetThermocouples
    global phidgetLoadCell
    global loadCellConnected
    global thermocouplesConnected
    
    while shutdown == False:
        if loadCellConnected == 1:
            #get data from the load cell
            phidget_data_and_times = phidgetLoadCell.getData()
        else:
            phidget_data_and_times = [[]]
        if thermocouplesConnected == 1:
            #get data from the thermocouples
            try:
                thermocouple_data_and_times = phidgetThermocouples.getData()
            except:
                #error getting thermocouple data
                print 'Problem with thermocouple board!'
#                 phidgetLoadCellTry = Phidget_Monitor.PhidgetBridge() 
#                 phidgetThermocouplesTry = Phidget_Monitor.PhidgetTemp()
#                 #open the phidget
#                 loadCellConnectedTry = phidgetLoadCellTry.open(1000) #wait 500 ms before timeout    
#                 thermocouplesConnectedTry = phidgetThermocouplesTry.open(1000)
        else:
            thermocouple_data_and_times = []
            
        #append the load cell data if there is new data
        if len(phidget_data_and_times[0]) > 0:
            load_cell_data.extend(phidget_data_and_times[0])
            load_cell_times.extend(phidget_data_and_times[1])
        #append the thermocouple data if there is new data
        if len(thermocouple_data_and_times) > 0:
            tc0_data.append(thermocouple_data_and_times[0])
            tc1_data.append(thermocouple_data_and_times[1])
            tc2_data.append(thermocouple_data_and_times[2])
            tc3_data.append(thermocouple_data_and_times[3])
            tc_times.append(thermocouple_data_and_times[4])
        
        time.sleep(READ_PHIDGET_BOARDS_INTERVAL_MS/1000.)

def serial_read():
    global pin_data
    global time_data
    global scale_data
    global time_data_scale
    global load_cell_data
    global load_cell_times
    global tc0_data
    global tc1_data
    global tc2_data
    global tc3_data
    global tc_times
    global sample_rate
    global python_time_at_first_arduino_time
    global python_time_at_first_scale_time
    if arduinoMicroConnected == True:
        serial_data_micro = arduinoMicro.nextMicro()
        serial_data_scale = arduinoMicro.nextScale()
    else:
        serial_data_micro = []
        serial_data_scale = [[]]
    if arduinoMegaConnected == True:
        serial_data_mega = arduinoMega.nextMega()
    else:
        serial_data_mega = []
#     if loadCellConnected == 1:
#         #get data from the load cell
#         phidget_data_and_times = phidgetLoadCell.getData()
#     else:
#         phidget_data_and_times = [[]]
#     if thermocouplesConnected == 1:
#         #get data from the thermocouples
#         thermocouple_data_and_times = phidgetThermocouples.getData()
#     else:
#         thermocouple_data_and_times = []
#         
#     #append the load cell data if there is new data
#     if len(phidget_data_and_times[0]) > 0:
#         load_cell_data.extend(phidget_data_and_times[0])
#         load_cell_times.extend(phidget_data_and_times[1])
#     #append the thermocouple data if there is new data
#     if len(thermocouple_data_and_times) > 0:
#         tc0_data.append(thermocouple_data_and_times[0])
#         tc1_data.append(thermocouple_data_and_times[1])
#         tc2_data.append(thermocouple_data_and_times[2])
#         tc3_data.append(thermocouple_data_and_times[3])
#         tc_times.append(thermocouple_data_and_times[4])
    
    #see what signal was sent
#     if len(serial_data) == 1:
#         #
    #make sure that there is data in the micro
#     if len(serial_data_micro) == 11:
    if len(serial_data_micro) == 15:
        #see if this is the first data we get from the arduino
        if len(time_data) == 0 and (len(serial_data_micro[3]) > 0):
            python_time_at_first_arduino_time = time.time()-(serial_data_micro[3][-1]-serial_data_micro[3][0])/1000.0
        #we have 
#         pin_data[0].extend(np.array(serial_data_micro[0])/1023.0*5)
#         pin_data[1].extend(np.array(serial_data_micro[1])/1023.0*5)
#         pin_data[2].extend(np.array(serial_data_micro[2])/1023.0*5)
#         pin_data[3].extend(np.array(serial_data_micro[3])/1023.0*5)
#         pin_data[0].extend(np.array(serial_data_micro[0])*1.335377-241.25657)
        pin_data[0].extend(np.array(serial_data_micro[0])*1.180655-252.323)
#         pin_data[1].extend(np.array(serial_data_micro[1])*5.13756-615.19168)
#         pin_data[1].extend(np.array(serial_data_micro[1])*1.42486-226.25393)
        pin_data[1].extend(np.array(serial_data_micro[1])*1.199276-252.386)
#         pin_data[2].extend(np.array(serial_data_micro[2])*2.0372896-247.77095)
#         pin_data[2].extend(np.array(serial_data_micro[2])*1.688892-250.115)
        pin_data[2].extend(np.array(serial_data_micro[2])*2.926983-517.471)
#         pin_data[3].extend(np.array(serial_data_micro[3])*1.42486-226.25393)
        time_data.extend(np.array(serial_data_micro[3])/1000.0)
        sample_rate = serial_data_micro[4]
        is_armed = serial_data_micro[5][0]
        emergency_stop = serial_data_micro[6][0]
        updates = serial_data_micro[7]
        valve_1_status = serial_data_micro[8]
        valve_2_status = serial_data_micro[9]
        valve_3_status = serial_data_micro[10]
        valve_4_status = serial_data_micro[11]
        valve_5_status = serial_data_micro[12]
        valve_6_status = serial_data_micro[13]
        igniter_status = serial_data_micro[14]
        #update the valve and igniter labels
        if valve_1_status == 1:
            uiplot.labelValve1.setText('Open')
            uiplot.labelValve1.setPalette(paletteOpen)
        else:
            uiplot.labelValve1.setText('Closed')
            uiplot.labelValve1.setPalette(paletteClosed)
        if valve_2_status == 1:
            uiplot.labelValve2.setText('Open')
            uiplot.labelValve2.setPalette(paletteOpen)
        else:
            uiplot.labelValve2.setText('Closed')
            uiplot.labelValve2.setPalette(paletteClosed)
        if valve_3_status == 1:
            uiplot.labelValve3.setText('Open')
            uiplot.labelValve3.setPalette(paletteOpen)
        else:
            uiplot.labelValve3.setText('Closed')
            uiplot.labelValve3.setPalette(paletteClosed)
        if valve_4_status == 1:
            uiplot.labelValve4.setText('Open')
            uiplot.labelValve4.setPalette(paletteOpen)
        else:
            uiplot.labelValve4.setText('Closed')
            uiplot.labelValve4.setPalette(paletteClosed)
        if valve_5_status == 1:
            uiplot.labelValve5.setText('Open')
            uiplot.labelValve5.setPalette(paletteOpen)
        else:
            uiplot.labelValve5.setText('Closed')
            uiplot.labelValve5.setPalette(paletteClosed)
        if valve_6_status == 1:
            uiplot.labelValve6.setText('Open')
            uiplot.labelValve6.setPalette(paletteOpen)
        else:
            uiplot.labelValve6.setText('Closed')
            uiplot.labelValve6.setPalette(paletteClosed)
        if igniter_status == 1:
            uiplot.labelIgniter.setText('Open')
            uiplot.labelIgniter.setPalette(paletteOpen)
        else:
            uiplot.labelIgniter.setText('Closed')
            uiplot.labelIgniter.setPalette(paletteClosed)
        
        if len(updates) > 0:
            #the arduino sent us a message
            for update in updates:
                #get the time
                updateText = update[0:update.find(':')+2]
                updateTime = float(update[update.find(':')+2:])/1000 - time_data[0]
                uiplot.textBrowser.append(updateText + '%.4f sec' % updateTime)
                #see which launch step was performed
                if updateText[updateText.find('Launch step') + 12] == '1':
                    launch1_times.append(updateTime)
                elif updateText[updateText.find('Launch step') + 12] == '2':
                    launch2_times.append(updateTime)
                elif updateText[updateText.find('Launch step') + 12] == '3':
                    launch3_times.append(updateTime)
                elif updateText[updateText.find('Launch step') + 12] == '4':
                    launch4_times.append(updateTime)
                elif updateText[updateText.find('Purge step') + 11] == '1':
                    purge1_times.append(updateTime)
                elif updateText[updateText.find('Purge step') + 11] == '2':
                    purge2_times.append(updateTime)
                elif updateText[updateText.find('Purge step') + 11] == '3':
                    purge3_times.append(updateTime)
                elif updateText[updateText.find('Purge step') + 11] == '4':
                    purge4_times.append(updateTime)
                elif updateText[updateText.find('Purge step') + 11] == '5':
                    purge5_times.append(updateTime)
                elif updateText[updateText.find('Purge step') + 11] == '6':
                    purge6_times.append(updateTime)
#         if emergency_stop == 1:
#             #the emergency button has been pressed!
# #             ctypes.windll.user32.MessageBoxA(0,'Emergency Stop', 'Emergency Stop Has Been Pressed!',1)
#             palette = Qt.QPalette()
#             palette.setColor(Qt.QPalette.Foreground,Qt.Qt.red)
#             uiplot.labelEmergency.setText('STOPPED!')
# #             uiplot.btnA.setEnabled(1) #SHOULD BE 0
# #             uiplot.btnB.setEnabled(1)
# #             uiplot.btnC.setEnabled(1)
#             uiplot.pushButtonLaunch.setEnabled(1)
#         else:
#             palette = Qt.QPalette()
#             palette.setColor(Qt.QPalette.Foreground,Qt.Qt.green)
#             uiplot.labelEmergency.setText('RUNNING...')
# #             uiplot.btnA.setEnabled(1)
# #             uiplot.btnB.setEnabled(1)
# #             uiplot.btnC.setEnabled(1)
#             uiplot.pushButtonLaunch.setEnabled(1)
#         uiplot.labelEmergency.setPalette(palette)
#         if is_armed == 1:
#             palette = Qt.QPalette()
#             palette.setColor(Qt.QPalette.Foreground,Qt.Qt.green)
#             uiplot.labelArmed.setText('ARMED')
#             uiplot.pushButtonLaunch.setStyleSheet("background-color: green")
#             uiplot.pushButtonLaunch.setEnabled(1)
#         else:
#             palette = Qt.QPalette()
#             palette.setColor(Qt.QPalette.Foreground,Qt.Qt.red)
#             uiplot.labelArmed.setText('NOT ARMED')
#             uiplot.pushButtonLaunch.setStyleSheet("background-color: red")
#             uiplot.pushButtonLaunch.setEnabled(0) #SHOULD BE 0
#         uiplot.labelArmed.setPalette(palette)
    #end of if there is data in the micro arduino
    #see if there is data in the scale
    if len(serial_data_scale[0]) > 0:
        #see if this is the first data we get from the scale
        if len(time_data_scale) == 0 and (len(scale_data) > 0):
            python_time_at_first_scale_time = time.time()-(serial_data_scale[1][-1]-serial_data_scale[1][0])/1000.0
        scale_data.extend(serial_data_scale[0])
        time_data_scale.extend(np.array(serial_data_scale[1])/1000.0)

def clear_text_button():
    global textHistory
    #save the old text
    textHistory.append(uiplot.textBrowser.toPlainText())
    uiplot.textBrowser.clear()

def clear_data_button():
    global pin_data
    global time_data
    global python_start_time_s
    global light_on_times
    global light_off_times
    global tc0_data
    global tc1_data
    global tc2_data
    global tc3_data
    global tc_times
    global scale_data
    global time_data_scale
    global load_cell_data
    global load_cell_times
    global save_filename_data
    global save_filename_text
    
    uiplot.textBrowser.append('Data history cleared at ' + str(time_data[-1] - time_data[0]) + ' sec')
#     uiplot.textBrowser.append('Data history cleared at %.4f sec' % (time.time() - python_start_time_s))
    #save the data if the box is checked
    if uiplot.checkBoxSaveData.isChecked():
        saveData()
    while savingData == True:
        'Don''t clear data when saving'
    pin_data = [[],[],[],[],[],[]] #6 pins
    time_data = []
    light_on_times = []
    light_off_times = []
    tc0_data = []
    tc1_data = []
    tc2_data = []
    tc3_data = []
    tc_times = []
    scale_data = []
    time_data_scale = []
    load_cell_data = []
    load_cell_times = []
    python_start_time_s = time.time()
    
    #create new filenames
    time_text = str('%04i' %time.localtime().tm_year) + str('%02i' %time.localtime().tm_mon) + \
        str('%02i' %time.localtime().tm_mday) + str('%02i' %time.localtime().tm_hour) + str('%02i' %time.localtime().tm_min) + \
        str('%02i' %time.localtime().tm_sec)
    save_filename_data = 'data' + time_text + '.csv'
    save_filename_text = 'text' + time_text + '.csv'

def checkStopFill():
    # This is a continuously running function that will see if the check box for stop filling is checked and if we want to close the fill valve
    while shutdown == False:
        if uiplot.checkBoxStopFill.isChecked() and len(pin_data[PRESSURE_SENSOR_TANK_PIN_INDEX]) > 0:
            try:
                if pin_data[PRESSURE_SENSOR_TANK_PIN_INDEX][-1] > int(uiplot.lineEditFill.text()):
                    #send a signal to the arduino to close the fill valve
                    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_1_CLOSE_INDEX])
            except:
                print 'ENTER SOMETHING IN THE FILL PRESSURE MAX'
                
def launch_process():
    #this is called when the launch command is sent to the arduino
    #start the countdown
    uiplot.labelCountdownMode.setText('T minus')
    for i in xrange(11):
        if arduinoMicro.abort == False:
            uiplot.labelCountdown.setText(str(10-i))
            time.sleep(1)
    #the program will wait the desired launch time and then send the stop launch command to the arduino
    if arduinoMicro.abort == False:
        uiplot.labelCountdownMode.setText('T plus')
        uiplot.labelCountdown.setText('1')
    for i in xrange(int(uiplot.lineEditLaunchDuration.text())-1):
        if arduinoMicro.abort == False:
            time.sleep(1)
            uiplot.labelCountdown.setText(str(i+2))
    if arduinoMicro.abort == False:
        arduinoMicro.sendData(ARDUINO_COMMANDS[STOP_LAUNCH_INDEX]) # r
        uiplot.labelCountdownMode.setText('Launch Completed')
        time.sleep(0.5)
        uiplot.labelCountdownMode.setText('Waiting')
        uiplot.labelCountdown.setText('--')
    #AUTOMATICALLY PURGE 0.5 SEC AFTER LAUNCH ENDS!!!
    if arduinoMicro.abort == False:
        purge_button()
    
    

def valve_1_open_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_1_OPEN_INDEX]) # a
    uiplot.textBrowser.append('Valve 1 opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_1_close_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_1_CLOSE_INDEX]) # b
    uiplot.textBrowser.append('Valve 1 closed at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_2_open_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_2_OPEN_INDEX]) # c
    uiplot.textBrowser.append('Valve 2 opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_2_close_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_2_CLOSE_INDEX]) # d
    uiplot.textBrowser.append('Valve 2 closed at ' + str(time_data[-1] - time_data[0]) + ' sec')

def valve_3_open_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_3_OPEN_INDEX]) # e
    uiplot.textBrowser.append('Valve 3 opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_3_close_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_3_CLOSE_INDEX]) # f
    uiplot.textBrowser.append('Valve 3 closed at ' + str(time_data[-1] - time_data[0]) + ' sec')

def valve_4_open_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_4_OPEN_INDEX]) #g
    uiplot.textBrowser.append('Valve 4 opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_4_close_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_4_CLOSE_INDEX]) #h
    uiplot.textBrowser.append('Valve 4 closed at ' + str(time_data[-1] - time_data[0]) + ' sec')

def valve_5_open_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_5_OPEN_INDEX]) #i
    uiplot.textBrowser.append('Valve 5 opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_5_close_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_5_CLOSE_INDEX]) # j
    uiplot.textBrowser.append('Valve 5 closed at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_6_open_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_6_OPEN_INDEX]) #k
    uiplot.textBrowser.append('Valve 6 opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def valve_6_close_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VALVE_6_CLOSE_INDEX]) #l
    uiplot.textBrowser.append('Valve 6 closed at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def vent_valve_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[VENT_INDEX]) # m
    uiplot.textBrowser.append('Vent Valve toggle started at ' + str(time_data[-1] - time_data[0]) + ' sec')
#     uiplot.textBrowser.append('Valve 1 opened at %.4f sec' % (time.time() - python_start_time_s))
    
def launch_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[LAUNCH_INDEX]) #n
    uiplot.textBrowser.append('Launch initiated at ' + str(time_data[-1] - time_data[0]) + ' sec')
    Thread(target=launch_process).start()
#     uiplot.textBrowser.append('Valve 2 opened at %.4f sec' % (time.time() - python_start_time_s))

def igniter_on_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[IGNITER_ON_INDEX]) #o
    uiplot.textBrowser.append('Igniter on at ' + str(time_data[-1] - time_data[0]) + ' sec')
#     uiplot.textBrowser.append('Valve 2 opened at %.4f sec' % (time.time() - python_start_time_s))

def igniter_off_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[IGNITER_OFF_INDEX]) #p
    uiplot.textBrowser.append('Igniter off at ' + str(time_data[-1] - time_data[0]) + ' sec')
#     uiplot.textBrowser.append('Valve 2 opened at %.4f sec' % (time.time() - python_start_time_s))
    
def purge_button():
    arduinoMicro.abort = False
    arduinoMicro.sendData(ARDUINO_COMMANDS[PURGE_INDEX]) #q
    uiplot.labelCountdownMode.setText('Purging')
    #start the purge messages
#     Thread(target=purge_messages).start()
    Thread(target=purge_countdown).start()
    
def abort_button():
    #Close all valves
    arduinoMicro.abort = True
    arduinoMicro.sendData(ARDUINO_COMMANDS[ABORT_INDEX]) #r
    uiplot.textBrowser.append('Abort at ' + str(time_data[-1] - time_data[0]) + ' sec')
    uiplot.labelCountdownMode.setText('Waiting')
    uiplot.labelCountdown.setText('--')
    
def purge_messages():
    if arduinoMicro.abort == False:
        uiplot.textBrowser.append('Purge processed started at ' + str(time_data[-1] - time_data[0]) + ' sec')
        uiplot.textBrowser.append('Nitrogen Vent Valve opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
        time.sleep(10)
    if arduinoMicro.abort == False:
        uiplot.textBrowser.append('Nitrogen Vent Valve closed at ' + str(time_data[-1] - time_data[0]) + ' sec')
        time.sleep(20)
    if arduinoMicro.abort == False:
        uiplot.textBrowser.append('Downstream Vent Valve opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
        time.sleep(2)
    if arduinoMicro.abort == False:
        uiplot.textBrowser.append('Downstream Vent Valve closed at ' + str(time_data[-1] - time_data[0]) + ' sec')
        time.sleep(0.5)
    if arduinoMicro.abort == False:
        uiplot.textBrowser.append('Nitrogen Vent Valve opened at ' + str(time_data[-1] - time_data[0]) + ' sec')
        time.sleep(5)
    if arduinoMicro.abort == False:
        uiplot.textBrowser.append('Nitrogen Vent Valve closed at ' + str(time_data[-1] - time_data[0]) + ' sec')
        uiplot.textBrowser.append('Purge process finished at ' + str(time_data[-1] - time_data[0]) + ' sec')
    
def purge_countdown():
    for i in xrange(38):
        if arduinoMicro.abort == False:
            uiplot.labelCountdown.setText(str(38-i-1))
            time.sleep(1)
    uiplot.labelCountdownMode.setText('Waiting')
    uiplot.labelCountdown.setText('--')
    
    
def arm_button():
    if uiplot.labelArmed.text() == 'NOT ARMED':
            palette = Qt.QPalette()
            palette.setColor(Qt.QPalette.Foreground,Qt.Qt.green)
            uiplot.labelArmed.setText('ARMED')
            uiplot.pushButtonLaunch.setStyleSheet("background-color: green")
            uiplot.pushButtonLaunch.setEnabled(1)
    else:
        palette = Qt.QPalette()
        palette.setColor(Qt.QPalette.Foreground,Qt.Qt.red)
        uiplot.labelArmed.setText('NOT ARMED')
        uiplot.pushButtonLaunch.setStyleSheet("background-color: red")
        uiplot.pushButtonLaunch.setEnabled(0) #SHOULD BE 0
    uiplot.labelArmed.setPalette(palette)
    
    
def saveData():
    global savingData
    global textHistory
    global save_filename_data
    global save_filename_text
    savingData = True
    #create the filename 
    #make rows of data to save
    if len(time_data) > 0:
        #find the maximum length of the data
        max_data_length = np.max([len(pin_data[0]),len(pin_data[1]),len(pin_data[2]),len(tc0_data),len(scale_data),len(load_cell_data)])
        header_row = ['Time Pressure Sensors (sec)','Pressure Sensor 1 (psi)','Pressure Sensor 2 (psi)','Pressure Sensor 3 (psi)', \
                      'Time Thermocouples (sec)','Thermocouple 1 (C)','Thermocouple 2 (C)','Thermocouple 3 (C)','Thermocouple 4 (C)', \
                      'Time Load Cell (sec)','Load Cell (N)','Time Scale (sec)','Scale (kg)']
        myfile = open(save_filename_data, 'wb')
        wr = csv.writer(myfile)
        wr.writerow(header_row)
        #write the rows
        for i in xrange(max_data_length):
            #make sure that there is data for the instrument to be written
            if len(pin_data[0]) <= i:
                row_to_write = ['','','','','']
            else:
                row_to_write = [time_data[i]-time_data[0],pin_data[0][i],pin_data[1][i],pin_data[2][i]]
            if len(tc_times) <= i:
                row_to_write.extend(['','','','',''])
            else:
                row_to_write.extend([tc_times[i]-python_time_at_first_arduino_time,tc0_data[i],tc1_data[i],tc2_data[i],tc3_data[i]])
            if len(load_cell_data) <= i or len(load_cell_times) <= i:
                row_to_write.extend(['',''])
            else:
                row_to_write.extend([load_cell_times[i]-python_time_at_first_arduino_time,load_cell_data[i]])
            if len(scale_data) <= i or len(time_data_scale) <= i:
                row_to_write.extend(['',''])
            else:
                row_to_write.extend([time_data_scale[i]-time_data[0],scale_data[i]])
            wr.writerow(row_to_write)
        #close the file
        myfile.close()
        
        #save the text
        myfile = open(save_filename_text, 'w')
        myfile.writelines(uiplot.textBrowser.toPlainText())
        myfile.close()
        
        savingData = False

#         time_row = ['Time']
#         time_row.extend(time_data-time_data[0])
#         pin_row = [['Pin 0'],['Pin 1'],['Pin 2'],['Pin 3'],['Pin 4'],['Pin 5']]
#         light_on_row = ['Light On Time']
#         light_on_row.extend(light_on_times)
#         light_off_row = ['Light Off Time']
#         light_off_row.extend(light_off_times)
#         launch1_row = ['Launch Step 1 Time']
#         launch1_row.extend(launch1_times)
#         launch2_row = ['Launch Step 2 Time']
#         launch2_row.extend(launch2_times)
#         launch3_row = ['Launch Step 3 Time']
#         launch3_row.extend(launch3_times)
#         myfile = open(save_filename_data, 'wb')
#         wr = csv.writer(myfile)
#         wr.writerow(time_row)
#     #     wr.writerow(time_data-time_data[0])
#         for pinIndex in xrange(6):
#             pin_row[pinIndex].extend(pin_data[pinIndex])
#             wr.writerow(pin_row[pinIndex])
#         wr.writerow(light_on_row)
#         wr.writerow(light_off_row)
#         wr.writerow(launch1_row)
#         wr.writerow(launch2_row)
#         wr.writerow(launch3_row)
#         wr.writerow(textHistory)
#         myfile.close()

def continuousSave():
    global savingData
    
    while shutdown == False:
        if uiplot.checkBoxSaveData.isChecked():
            time.sleep(SAVE_DATA_RATE_S)
            try:
                saveData()
            except:
                print 'Problem Saving'

def exitHandler():
    global shutdown
    #close the serial connections
    try:
        arduinoMicro.close()
        arduinoMega.close()
        phidgetLoadCell.close()
    except:
        'not all the devices were closed correctly'
    #save the data to the path specified if the box is checked
    shutdown = True
    if uiplot.checkBoxSaveData.isChecked():
        saveData()

if __name__ == "__main__":
    #start reading from the phidget boards
    Thread(target=readPhidgetBoards).start()
    
    app = QtGui.QApplication(sys.argv)
    app.aboutToQuit.connect(exitHandler)
    win_plot = ui_plot.QtGui.QMainWindow()
    uiplot = ui_plot.Ui_win_plot()
    uiplot.setupUi(win_plot)

    # tell buttons what to do when clicked
    uiplot.btnClrText.clicked.connect(clear_text_button)
    uiplot.btnClrData.clicked.connect(clear_data_button)
    uiplot.pushButtonVentValve.clicked.connect(vent_valve_button)
    uiplot.pushButtonLaunch.clicked.connect(launch_button)
    uiplot.pushButtonValve1Open.clicked.connect(valve_1_open_button)
    uiplot.pushButtonValve1Close.clicked.connect(valve_1_close_button)
    uiplot.pushButtonValve2Open.clicked.connect(valve_2_open_button)
    uiplot.pushButtonValve2Close.clicked.connect(valve_2_close_button)
    uiplot.pushButtonValve3Open.clicked.connect(valve_3_open_button)
    uiplot.pushButtonValve3Close.clicked.connect(valve_3_close_button)
    uiplot.pushButtonValve4Open.clicked.connect(valve_4_open_button)
    uiplot.pushButtonValve4Close.clicked.connect(valve_4_close_button)
    uiplot.pushButtonValve5Open.clicked.connect(valve_5_open_button)
    uiplot.pushButtonValve5Close.clicked.connect(valve_5_close_button)
    uiplot.pushButtonValve6Open.clicked.connect(valve_6_open_button)
    uiplot.pushButtonValve6Close.clicked.connect(valve_6_close_button)        
    uiplot.pushButtonIgniterOn.clicked.connect(igniter_on_button)
    uiplot.pushButtonIgniterOff.clicked.connect(igniter_off_button)
    uiplot.pushButtonPurge.clicked.connect(purge_button)
    uiplot.pushButtonAbort.clicked.connect(abort_button)
    uiplot.pushButtonArm.clicked.connect(arm_button)
    #uiplot.btnB.clicked.connect(lambda: uiplot.timer.setInterval(100.0))

    # set up the QwtPlot
    #PIN HISTORY
    pin0_curve=Qwt.QwtPlotCurve('Pin 0')  #make a curve
    pin1_curve=Qwt.QwtPlotCurve('Pin 1')  #make a curve
    pin2_curve=Qwt.QwtPlotCurve('Pin 2')  #make a curve
    pin3_curve=Qwt.QwtPlotCurve('Pin 3')  #make a curve
    pin4_curve=Qwt.QwtPlotCurve('Pin 4')  #make a curve
    pin5_curve=Qwt.QwtPlotCurve('Pin 5')  #make a curve
    temp1_curve=Qwt.QwtPlotCurve('Temp 1 ')  #make a curve
    temp2_curve=Qwt.QwtPlotCurve('Temp 2')  #make a curve
    temp3_curve=Qwt.QwtPlotCurve('Temp 3')  #make a curve
    temp4_curve=Qwt.QwtPlotCurve('Temp 4')  #make a curve
    scale_curve=Qwt.QwtPlotCurve('Scale')  #make a curve
    load_cell_curve = Qwt.QwtPlotCurve('Load Cell')  #make a curve
    light_on_curve=Qwt.QwtPlotCurve('Light On')
    light_off_curve=Qwt.QwtPlotCurve('Light Off')
    launch1_curve=Qwt.QwtPlotCurve('Launch 1')
    launch2_curve=Qwt.QwtPlotCurve('Launch 2')
    launch3_curve=Qwt.QwtPlotCurve('Launch 3')
    launch4_curve=Qwt.QwtPlotCurve('Launch 4')
    purge1_curve=Qwt.QwtPlotCurve('Purge 1')
    purge2_curve=Qwt.QwtPlotCurve('Purge 2')
    purge3_curve=Qwt.QwtPlotCurve('Purge 3')
    purge4_curve=Qwt.QwtPlotCurve('Purge 4')
    purge5_curve=Qwt.QwtPlotCurve('Purge 5')
    purge6_curve=Qwt.QwtPlotCurve('Purge 6')
    pin0_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    pin1_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    pin2_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    pin3_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    pin4_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    pin5_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    temp1_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    temp2_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    temp3_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    temp4_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    scale_curve.attach(uiplot.qwtPlot_3) 
    load_cell_curve.attach(uiplot.qwtPlot_3)
    pin0_curve.setYAxis(Qwt.QwtPlot.yRight)
    pin1_curve.setYAxis(Qwt.QwtPlot.yRight)
    pin2_curve.setYAxis(Qwt.QwtPlot.yRight)
    pin3_curve.setYAxis(Qwt.QwtPlot.yRight)
    pin4_curve.setYAxis(Qwt.QwtPlot.yRight)
    pin5_curve.setYAxis(Qwt.QwtPlot.yRight)
    temp1_curve.setYAxis(Qwt.QwtPlot.yLeft)
    temp2_curve.setYAxis(Qwt.QwtPlot.yLeft)
    temp3_curve.setYAxis(Qwt.QwtPlot.yLeft)
    temp4_curve.setYAxis(Qwt.QwtPlot.yLeft)
    scale_curve.setYAxis(Qwt.QwtPlot.yLeft)
    load_cell_curve.setYAxis(Qwt.QwtPlot.yRight)
    light_on_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    light_off_curve.attach(uiplot.qwtPlot) #attach it to the qwtPlot object
    launch1_curve.attach(uiplot.qwtPlot)
    launch2_curve.attach(uiplot.qwtPlot)
    launch3_curve.attach(uiplot.qwtPlot)
    launch4_curve.attach(uiplot.qwtPlot)
    purge1_curve.attach(uiplot.qwtPlot)
    purge2_curve.attach(uiplot.qwtPlot)
    purge3_curve.attach(uiplot.qwtPlot)
    purge4_curve.attach(uiplot.qwtPlot)
    purge5_curve.attach(uiplot.qwtPlot)
    purge6_curve.attach(uiplot.qwtPlot)
    
    #set the colors for each plot
    pin0_curve.setPen(Qt.QPen(Qt.Qt.black))
    pin1_curve.setPen(Qt.QPen(Qt.Qt.blue))
    pin2_curve.setPen(Qt.QPen(Qt.Qt.red))
    pin3_curve.setPen(Qt.QPen(Qt.Qt.green))
    pin4_curve.setPen(Qt.QPen(Qt.Qt.darkMagenta))
    pin5_curve.setPen(Qt.QPen(Qt.Qt.yellow))
    scale_curve.setPen(Qt.QPen(Qt.Qt.darkGreen))
    load_cell_curve.setPen(Qt.QPen(Qt.Qt.magenta))
    light_on_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    light_on_curve.setPen(Qt.QPen(Qt.Qt.green,5))
    light_off_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    light_off_curve.setPen(Qt.QPen(Qt.Qt.red,5))
    launch1_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    launch1_curve.setPen(Qt.QPen(Qt.Qt.darkBlue,5))
    launch2_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    launch2_curve.setPen(Qt.QPen(Qt.Qt.darkGreen,5))
    launch3_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    launch3_curve.setPen(Qt.QPen(Qt.Qt.darkRed,5))
    launch4_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    launch4_curve.setPen(Qt.QPen(Qt.Qt.yellow,5))
    purge1_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    purge1_curve.setPen(Qt.QPen(Qt.Qt.black,5))
    purge2_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    purge2_curve.setPen(Qt.QPen(Qt.Qt.red,5))
    purge3_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    purge3_curve.setPen(Qt.QPen(Qt.Qt.blue,5))
    purge4_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    purge4_curve.setPen(Qt.QPen(Qt.Qt.green,5))
    purge5_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    purge5_curve.setPen(Qt.QPen(Qt.Qt.magenta,5))
    purge6_curve.setStyle(Qwt.QwtPlotCurve.Sticks)
    purge6_curve.setPen(Qt.QPen(Qt.Qt.darkBlue,5))
    
    #CURRENT PINS
    pin0_bar=Qwt.QwtPlotCurve('Pin 0')  #make a BarChart
    pin1_bar=Qwt.QwtPlotCurve('Pin 1')  #make a BarChart
    pin2_bar=Qwt.QwtPlotCurve('Pin 2')  #make a BarChart
    pin3_bar=Qwt.QwtPlotCurve('Pin 3')  #make a BarChart
    pin4_bar=Qwt.QwtPlotCurve('Pin 4')  #make a BarChart
    pin5_bar=Qwt.QwtPlotCurve('Pin 5')  #make a BarChart
    scale_bar = Qwt.QwtPlotCurve('Scale')  #make a BarChart
    load_cell_bar=Qwt.QwtPlotCurve('Load Cell')  #make a BarChart
    sample_rate_bar=Qwt.QwtPlotCurve('Sample Rate')  #make a BarChart
#     pin0_bar.attach(uiplot.qwtPlot_2) #attach it to the qwtPlot object
#     pin1_bar.attach(uiplot.qwtPlot_2) #attach it to the qwtPlot object
#     pin2_bar.attach(uiplot.qwtPlot_2) #attach it to the qwtPlot object
#     pin3_bar.attach(uiplot.qwtPlot_2) #attach it to the qwtPlot object
#     pin4_bar.attach(uiplot.qwtPlot_2) #attach it to the qwtPlot object
#     pin5_bar.attach(uiplot.qwtPlot_2) #attach it to the qwtPlot object
#     pin0_bar.setYAxis(Qwt.QwtPlot.yRight)
#     pin1_bar.setYAxis(Qwt.QwtPlot.yRight)
#     pin2_bar.setYAxis(Qwt.QwtPlot.yRight)
#     pin3_bar.setYAxis(Qwt.QwtPlot.yRight)
    scale_curve.setYAxis(Qwt.QwtPlot.yLeft)
#     scale_bar.attach(uiplot.qwtPlot_2)
#     load_cell_bar.attach(uiplot.qwtPlot_2)
#     sample_rate_bar.attach(uiplot.qwtPlot_2) #attach it to the qwtPlot object
    #set the colors for each plot
    pin0_bar.setBrush(Qt.QBrush(Qt.Qt.black))
    pin1_bar.setBrush(Qt.QBrush(Qt.Qt.blue))
    pin2_bar.setBrush(Qt.QBrush(Qt.Qt.red))
    pin3_bar.setBrush(Qt.QBrush(Qt.Qt.green))
    pin4_bar.setBrush(Qt.QBrush(Qt.Qt.darkMagenta))
    pin5_bar.setBrush(Qt.QBrush(Qt.Qt.yellow))
    scale_bar.setBrush(Qt.QBrush(Qt.Qt.darkGreen))
    load_cell_bar.setBrush(Qt.QBrush(Qt.Qt.magenta))
    pin0_bar.setPen(Qt.QPen(Qt.Qt.black))
    pin1_bar.setPen(Qt.QPen(Qt.Qt.blue))
    pin2_bar.setPen(Qt.QPen(Qt.Qt.red))
    pin3_bar.setPen(Qt.QPen(Qt.Qt.green))
    pin4_bar.setPen(Qt.QPen(Qt.Qt.darkMagenta))
    pin5_bar.setPen(Qt.QPen(Qt.Qt.yellow))
    load_cell_bar.setPen(Qt.QPen(Qt.Qt.magenta))
    sample_rate_bar.setPen(Qt.QPen(Qt.Qt.darkGreen))
    
    #set the axis titles
    uiplot.qwtPlot.setAxisTitle(Qwt.QwtPlot.xBottom, "Time (sec)")
    uiplot.qwtPlot.setAxisTitle(Qwt.QwtPlot.yLeft, "Temperature (C)")
    uiplot.qwtPlot.enableAxis(Qwt.QwtPlot.yRight)
    uiplot.qwtPlot.setAxisTitle(Qwt.QwtPlot.yRight, "Pressure (psi)")
    uiplot.qwtPlot.setTitle('Temperature and Pressure')
#     uiplot.qwtPlot_2.setAxisTitle(Qwt.QwtPlot.xBottom, "Pin Number")
#     uiplot.qwtPlot_2.setAxisTitle(Qwt.QwtPlot.yLeft, "Voltage (V)")
#     uiplot.qwtPlot_2.enableAxis(Qwt.QwtPlot.yRight)
#     uiplot.qwtPlot_2.setAxisTitle(Qwt.QwtPlot.yRight, "Pressure (psi)")
#     uiplot.qwtPlot_2.setTitle('Current Signals')
#     uiplot.qwtPlot_2.setAxisScale(Qwt.QwtPlot.xBottom,-0.5,5.5)
#     uiplot.qwtPlot_2.setAxisScale(Qwt.QwtPlot.yLeft,0,5)
    uiplot.qwtPlot_3.setAxisTitle(Qwt.QwtPlot.xBottom, "Time (sec)")
    uiplot.qwtPlot_3.setAxisTitle(Qwt.QwtPlot.yLeft, "Scale (kg)")
    uiplot.qwtPlot_3.enableAxis(Qwt.QwtPlot.yRight)
    uiplot.qwtPlot_3.setAxisTitle(Qwt.QwtPlot.yRight, "Load Cell (N)")
    uiplot.qwtPlot_3.setTitle('Scale and Load Cell')
    uiplot.lineEditFill.setInputMask("0000")
    uiplot.lineEditFill.setMaxLength(4)
    uiplot.lineEditLaunchDuration.setInputMask("00")
    uiplot.lineEditFill.setMaxLength(2)
    
    #set valve label colors
    
                                     
    #start timers
    read_data_timer = QtCore.QTimer() #start a timer (to read in the serial data)
    read_data_timer.start(READ_DATA_INTERVAL_MS) #set the interval (in ms)
    win_plot.connect(read_data_timer, QtCore.SIGNAL('timeout()'), serial_read)
    uiplot.timer = QtCore.QTimer() #start a timer (to call replot events)
    uiplot.timer.start(REPLOT_INTERVAL_MS) #set the interval (in ms)
    win_plot.connect(uiplot.timer, QtCore.SIGNAL('timeout()'), plotSomething)
    
    # show the main window
    win_plot.show()
    #get the start time
    python_start_time_s = time.time()
    
    #activate the load cell check box if the load cell is attached
    if loadCellConnected == 1:
        uiplot.checkBoxLoadCell.setCheckable(True)
        uiplot.checkBoxLoadCell.setChecked(True)

    #start the continuous saving
    Thread(target=continuousSave).start()
    
    #start the check stop fill thread
    Thread(target=checkStopFill).start()
    
    sys.exit(app.exec_())
